# ANNOTATIONSSão metadados adicionados para se relacionem com classes, métodos, atributos, parâmetros e variáveis. Podendo ser utilizados tanto em tempo de execução ou como em compilação.Isso pode trazer coisas como quando em tempo de compilação pode-se gerar código ou até modificar o bytecode. No entanto, as anotações ou a sua declaração seja em qual parte do código estiver, são removidas do bytecode desta classe anotada.As ~Annotations~ são utilizadas numa diversidade de grande frameworks como o ~Lombok~ que pode gerar rotinas comummente usadas em POJOs, como exemplo em getters, setters, toString, equals e hashCodes.As annotations surgiram a partir da versão 5 do Java, para ajudar em coisas como uso extensivo de XML para auxiliar em coisas como configurações, mapeamento de dados, comunicação entre sistemas de diferentes plataformas dentre muitas outras finalidades.## Criação de AnnotationsPara a criação de uma ~Annotation~ seria algo representado como: ````java@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.FIELD)public @interface NomeDaAnnotation {      MeuEnum meuEnum() default MeuEnum.TIPO_A;}````### Explicando1. Usa-se a palavra reservada `@interface` para definir que é uma ~Annotation~.2. ~Annotations~ possuem meta-anotações como a `@Retention`, que serve para definir política de retenção que utiliza, como se o que está sendo anotado será verificado em tempo de execução ou em tempo de compilação, e tem três valores:   1. [RetentionPolicy.RUNTIME](#RetentionPolicy.RUNTIME-id);    2. [RetentionPolicy.SOURCE](#RetentionPolicy.SOURCE-id);    3. [RetentionPolicy.CLASS](#RetentionPolicy.CLASS-id).3. Uma outra meta-anotação seria `@Target` que define a categoria de elemento que a anotação será utilizada, possuindo muitos tipos, como exemplo:   1. [Target(ElementType.FIELD)](#Target(ElementType.FIELD)-id);   2. [Target(ElementType.METHOD)](#Target(ElementType.METHOD)-id);   3. [Target(ElementType.CONSTRUCTOR)](#Target(ElementType.CONSTRUCTOR)-id);   4. [Target(ElementType.PACKAGE)](#Target(ElementType.PACKAGE)-id);   5. Entre outros.4. Também pode conter informações que serão utilizadas para definir o comportamento desta ~Annotation~, um exemplo poderia definir um `enum` para determinar isso:   1. `public enum MeuEnum { PAR, IMPAR }`, que define como exemplo se verificara números ~Pares~ ou ~Impares~. Mas que seria usado na anotação `MeuEnum tipo() default MeuEnum.PAR;`.5. As ~Annotations~ precisam de ~Reflections~ para conseguir realizar o seu propósito, sendo assim a implementação destas deve ser feita.## <a href=RetentionPolicy.RUNTIME-id>&nbsp;</a>* RetentionPolicy.RUNTIME: são retidas durante o tempo de execução, e podem ser acessadas durante o tempo de execução.<a href="RetentionPolicy.SOURCE-id">&nbsp;</a>* RetentionPolicy.SOURCE: são descartadas em tempo de execução.<a href="RetentionPolicy.CLASS-id">&nbsp;</a>* RetentionPolicy.CLASS: são registradas no arquivo `.class`, mas são descartadas durante o tempo de execução. Sendo a política de retenção padrão e/ou `default`.<a href="Target(ElementType.FIELD)-id">&nbsp;</a>* Target(ElementType.FIELD): a anotação servirá para atributos da classe que estão utilizando a anotação.<a href="Target(ElementType.METHOD)-id">&nbsp;</a>* Target(ElementType.METHOD): servirá para métodos.<a href="Target(ElementType.CONSTRUCTOR)-id">&nbsp;</a>* Target(ElementType.CONSTRUCTOR): servirá para construtores.<a href="Target(ElementType.PACKAGE)-id">&nbsp;</a>* Target(ElementType.PACKAGE): servirá para pacotes.<a href="Polimorfismo-id">&nbsp;</a>* Polimorfismo: uma das características do paradigma `Orientado a Objetos`, onde permite que uma mesma mensagem tenha diferentes formas de responder. Onde na linha de raciocínio da programação pode ser dito algo como, quando temos um método que implementa diferentes formas, podendo ser chamado das classes que o possuem e ser respondido de diferentes formas. (Polimorfismo: Poli = forma; Morfismo = diferente)2022.05.02 MAURICIO MITYO HIDANI